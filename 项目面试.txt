### 项目介绍

乐优商城是一个B2C模式的电商购物网站。

用户可以在线对商品进行浏览、搜索、加入购物车、下单等，

管理员可以在后台管理商品的上下架等。



### 项目架构

整个项目采用的是前后端分离开发模式。

- 前端分为两部分：

  - 后台管理：主要面向的是数据管理人员，采用基于Vue的单页应用开发方式
  - 门户系统：面向的是客户，门户采用的是Vue结合Nuxt实现服务端渲染方式

- 后端

  后端采用基于SpringCloud的微服务架构，统一对外提供Rest风格接口，无论是后台管理还是门户系统都共享这些微服务接口，而微服务中通过JWT方式来识别用户身份，开放不同接口。

![项目架构图](.\assets\lysc.png)

### 跨域解决方案

- Jsonp

  最早的解决方案，利用script标签可以跨域的原理实现。

  限制：

  - 需要服务的支持
  - 只能发起GET请求

- nginx反向代理

  思路是：利用nginx把跨域反向代理为不跨域，支持各种请求方式

  缺点：需要在nginx进行额外配置，语义不清晰 

- CORS （cross-orgin resource sharing)

  规范化的跨域请求解决方案，安全可靠。

  优势：

  - 在服务端进行控制是否允许跨域，可自定义规则
  - 支持各种请求方式

  缺点：

  - 会产生额外的请求

    

#### 原理

- 简单请求

- 特殊请求（先发预检请求）

#### 使用： 
   SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter 
   ```java
   @Configuration
public class LeyouCorsConfig {
    @Bean
    public CorsFilter corsFilter() {
        //1.添加CORS配置信息
        CorsConfiguration config = new CorsConfiguration();
        //1) 允许的域,不要写*，否则cookie就无法使用了
        config.addAllowedOrigin("http://manage.leyou.com");
        //2) 是否发送Cookie信息
        config.setAllowCredentials(true);
        //3) 允许的请求方式
        config.addAllowedMethod("OPTIONS");
        config.addAllowedMethod("HEAD");
        config.addAllowedMethod("GET");
        config.addAllowedMethod("PUT");
        config.addAllowedMethod("POST");
        config.addAllowedMethod("DELETE");
        config.addAllowedMethod("PATCH");
        // 4）允许的头信息
        config.addAllowedHeader("*");

        //2.添加映射路径，我们拦截一切请求
        UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource();
        configSource.registerCorsConfiguration("/**", config);

        //3.返回新的CorsFilter.
        return new CorsFilter(configSource);
    }
}
   ```



### SPU SKU

- SPU：Standard Product Unit （标准产品单位） ，一组具有共同属性的商品集

- SKU：Stock Keeping Unit（库存量单位），SPU商品集因具体特性不同而细分的每个商品

![1569159264787](./assets/1569159264787.png)

### RESTful

REST : resource respresention state tranfer

- Url描述要什么，所以常常拼接的应该是名词
- http method 描述要干什么， get post put delete
- http status code 描述结果如何

### 全文检索 Lucene

- 全文检索： 先建立索引，再对索引进行搜索的过程。 而索引指：将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构
- ![1569167659446](./assets/235308.png)

### ElasticSearch

Indices---数据库

type---表

document---行

filed---列



- 索引的创建、映射配置、
- 数据的添加、智能判断、修改、删除
- 数据的查询(基本查询match/term..., 高级查询bool/range/fuzzy) ->字段过滤(_source,includes,excludes)->结果过滤->排序
- 数据的聚合查询
  - 桶-----分组的意思
  - 度量-----max/avg 等统计的意思

- spring data elasticsearch
  - ElasticSearchTemplate -----索引的创建
  - ElasticSearchRespository-----文档的基本增删改查
  - NativeSearchQueryBuilder-----文档的高级查询（原生查询）

### ThymeLeaf

- 页面静态化
  - Context：运行上下文， 可获取数据
  - TemplateResolver: 模板解析器， 模板相关的配置
  - TemplateEngine: 解析模板的引擎，依赖于上两点

### MQ

1. MQ 是一种消息通信模型，主流实现有：
   - JMS(java message service, 只能用java，规定了两种消息模型)
   - AMQP(advanced message queuing protocol, 高级消息队列协议，只是协议，没有规定实现，夸语言)

### RabbitMQ

- 消息确认机制(ack)，防止消费者丢失信息导致信息丢失
  - 自动ack, 默认, 一收到消息就ack响应
  - 手动ack， 一般收到消息后且消息被正确应用后，手动ack响应

- 持久化，防止消息服务器宕机导致的信息丢失

  - 交换机持久化
  - 队列持久化
  - 消息持久化

- 6中消息模型

  ![6种消息模型](./assets/142421.png)

  - basic:  一生产、一消费、一队列
  - work: 一生产、一队列、多消费
  - 订阅模型：主要是exchange 的类型不同
    - fanout: 广播，交换机给每个绑定到自己的消息队列发转发消息
    - direct: 发送的消息和消息队列都有routing_key， 若两者相等，才把消息入队
    - topic: 类似direct， 不同的是routing_key可以使用通配符， #匹配>=1个， * 匹配 = 1 个

### Spring AMQP

目前唯一的实现是 spring-rabbit ， 底层用的是RabbitMQ

- 发送消息： AmqpTemplate 类
- 接受消息：@Component 类加入容器， 类中方法上加注解@RabbitListener() 指定交换机、队列、路由键、和交换机的类型（即消息模型：topic/direct...）
- 主要消息的发送接收应被try catch ，异常时不能影响正常业务逻辑

### Redis







### Hibernate Validate



# 授权中心

### JWT（json web token) + RSA非对称加密算法实现的 无状态登录

包含3部分数据：

- Header: 经Base64编码，通常有两部分信息
  - 加密算法类型
  - tpe: "JWT"

- Payload:经Base64编码， 一般放我们想要传输的信息
- signature:  HS256(Base64(Header) + "." + Base64(Payload), secretKey)

### JWT 交互流程

- 首先授权中心利用RSA生成公钥和私钥。私钥保存在授权中心，公钥分发到Zuul和各个信任的微服务
- 用户请求登录
- 授权中心调用用户中心服务验证，通过后，用私钥生成JWT（即token）通过cookie返回给用户
- 用户此后的请求携带JWT(token)
- 请求会先到达Zuul， zuul通过公钥解密JWT，进行验证，若验证通过，刷新token，然后放行, 将请求路由到微服务
- 请求到达微服务，微服务也用用公钥解析JWT，进行验证，获取用户信息，无需访问授权中心

### 坑：cookie 写入问题

- 首先确保跨域设置允许携带cookie, 允许跨域的域不能写通配符*

- zuul 的敏感头过滤， set-cookie包含在其中，索引cookie设置失败
- cookie 的domain信息不正确

  - 原因：用户请求经过nginx反向代理到zuul，zuul又路由到授权服务模块，原理的host被改动

- 解决办法：

  1. zuul敏感头过滤设置为空

     - 方式1： zuul 全局设置 zuul.sensitive-headers=

     - 方式2： 针对微服务设置

       zuul.routes.<routeName>.custome-sensitive-headers: true

       zuul.routes.<routeName>.sentive-headers=

  2. nginx配置，让它不要修改host: proxy_set_header Hst $host

  3. zuul设置携带请求本身的header头信息：

     zuul.add-host-header: true

### 刷新token

每次验证请求的token成功后，都生成一个新的token设置到cookie返回客户端覆盖原来的token

### 注意：zuul网关登录拦截器

- 拦截白名单： 拦截器的shouldFilter() 处添加判断逻辑
- 不应拦截的有：
  - 授权接口的请求
  - 用户注册相关的接口请求
  - 搜索微服务的请求

- 拦截逻辑： 获取cookie中的token，用公钥验证token， 通过则路由到相应微服务模块

### 雪花算法

64bit:

第一位：为未使用

第二部分：41位为毫秒级时间(41位的长度可以使用69年)

第三部分：5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点）

第四部分：最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号）