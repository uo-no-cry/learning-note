### JVM的主要组成部分及其作用

\1. 类加载器（ClassLoader）

\2. 运行时数据区（Runtime Data Area）

\3. 执行引擎（Execution Engine）

\4. 本地库接口（Native Interface）

各组件的作用：前端编译器javac把java代码编译成字节码文件后，类加载器负责吧字节码文件加载到运行时数据区，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器：执行引擎，它调用本地库接口，将字节码翻译成底层系统指令，再交由 CPU 去执行。



### 谈谈你对运行时数据区的理解

运行时数据区由线程共享的堆、方法区和线程隔离的java虚拟机栈、本地方法栈、程序计数器组成。

- 程序计数器可以看出当前程序所指向的字节码的行号的指示器，当执行的是java方法时，这个计数器记录的是虚拟机字节码指令的地址，如果执行的是native方法，则这个计数器为空。
- java虚拟机栈描述的是java方法执行的内存模型：每一个方法在执行的同时都会创建一个栈桢用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
- 本地方法栈与java虚拟机栈的作用类似，不同的是java 虚拟机栈为java方法服务，而本地方法栈为native方法服务。
- 堆，堆的主要目的是存放对象实例，几乎所有的对象以及数组都要在堆上分配。从内存回收的角度来看，由于现在的收集器基本都采用分代收集算法，所以堆可以细分成新生代、老年代。
- 方法区用于存储已经被虚拟机加载的类信息、常量和即时编译器编译后的代码等数据。方法区中有运行时常量池，它的作用是存放class文件中的常量池中的各种字面量和符号引用以及符号引用被翻译后的直接引用。

### 常见的垃圾收集器有哪些

新生代：

- Serial

  单线程收集器，使用复制算法，优点是简单有效（与其他收集器的单线程来比较），因为没有线程交互的开销。可与CMS、 Serial Old搭配使用。

- ParNew

  其实就是Serial收集器的多线程版本，采用的也是复制算法，在多核CPU下有比Serial更好的表现。和与CMS、Serial Old 搭配使用。

- Parallel Scavenge

  一款并行的多线程收集器，使用复制算法，目标是达到一个可控制的吞吐量，主要适合在后台运算而不需要太多交互的任务。提供两个精确控制吞吐量的参数： -XX:MaxGCPauseMillis   -XX:GCTimeRatio, 和以和Serial Old 或 Parallel Old 搭配使用。

老年代：

- Parallel Old

  Parallel Scavenge 的老年代版本，使用多线程和“标记-整理”算法。Parallel Scavenge 和 其搭配使用，才能真正体现“吞吐量优先” 。

- CMS

  一款高并发、低停顿的收集器。适合使用在重视服务响应速度以给用户带来良好的用户体验的服务端。使用的是“标记-清楚”算法。有3个明显的缺点：对CPU资源非常敏感；无法处理浮动垃圾；产生大量空间碎片。

G1:

​	G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region

### 类加载机制

虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载 7 个阶段。其中验证、准备、解析 3 个部分统称为连接。

- 加载

  \1. 通过一个类的全限定名来获取定义此类的二进制字节流；

  \2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；

  \3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。

- 验证

  确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

- 准备

  正式为类变量分配内存并设置类变量初始值为零值的阶段。

- 解析

  解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

  - 符号引用： 描述所引用目标的一组符号。
  - 直接引用：可以是直接指向目标的指针，相对偏移量或一个能间接定位到目标的句柄。

- 初始化

  根据程序员制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器 <clinit>() 方法的过程。

  

  



### clinit 和 init

clinit和init 是在javac编译过程的最后一个阶段-字节码生成 阶段添加到语法树种的。

- clinit

  > 是由编译器自动收集类中所有类变量的赋值动作和静态语句块static{}中的语句合并产生的。
  >
  > clinit不需要显示调用父类的clinit, 因为虚拟机会保证父类的clinit先执行完毕；接口的clinit不需要先执行父接口的clinit; 虚拟机会保证一个类的clinit在多选成的环境中被正确的加锁、同步。

- init

  > 不等于默认构造函数。是编译器将语句块{}、实例变量初始化、调用父类的实例构造器等操作收敛而成。



### 父类子类-类变量实例变量初始化顺序

实验  People <=  Man    

结果：

```java
Dog{name='people's static dog', id=222}
people static{}
Dog{name='man's static dog2', id=321}
man static{}
Dog{name='people's dog', id=111}
people {}
people constructor
Dog{name='man's dog', id=123}
man {}
man constructor
```

结论：

- 静态的 -> 非静态的
- 父类 -> 子类
- 静态的资源初始化顺序：
  - 类变量 -> 静态代码块 

- 非静态的顺序：
  - 实例变量 -> 代码块{} -> 构造函数



### volatile 原理

1. volatile 特性：可见性，静止指令重排序

2. 原理：

   - java内存模型中定义了8种操作来同步工作内存与主内存
   - 这8种操作都是原子性的
   - 执行8中操作必须满足一些规则：
     - 其中有一条：对一个变量执行unlock操作之前，必须把此变量从工作内存同步会主内存

   - 对volatiole变量修改以后，会多执行一个“lock addl $0x0, (%esp)”的操作， 也就是加锁进行一个空操作，随后需要进行解锁unlock， 把工作内存中的volatile修饰的变量同步回主内存（可见性保证第一步），同时也意味着所有前面的指令都已经执行完毕（没有给后面的指令重排序到前面的机会）。
   - 可见性保证第二步：use操作前必须执行一个load操作，也就是说，使用一个变量前，必须先从主内存刷新最新的值。
   - 也就是说，可见性是因为voltile变量修改时，能立即刷回主内存，调用前能立即从主内存刷新。

### 原子性、可见性、有序性

- 原子性保证的有：read、load、store、write以及更高级的字节码指令monitorener、monitorexit； 而lock和unlock未直接开发给用户使用。
- 可见性保证的有：volatile，synchronized, final
- 有序性保证的有：volatile, synchronized

### 并行与并发

并行是指多个事件在同一时刻发生，并发是指多个时间在某一时间间隔发生；

在单核cpu上“同时”处理多个任务就是并发，在多核cup上同时处理多个任务就是并行。